类：对一群具有相同特征对象的集合的描述；

对象：真实存在的对象个体；js中核心API（js一切皆对象）；

函数：函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块。函数按照其声明分为三种：

1、函数声明方式：function sum (){}; 调用：sum();

2、表达式声明方式：var sum = function(){}; 调用：sum();

3、使用构造函数（构造器）方式：var sum = new Funcion(); 调用：sum();



#### 匿名函数的用途（没有函数名的函数）

##### 一、自执行的匿名函数

​	1、什么是自执行的匿名函数？

​		它是指类似这样的函数(function(){ some code })();

​	2、疑问，为什么(function(){ some code })()可以被执行，而function(){ somecode }()会报错

```javascript
	>1.首先两者的区别：
	>
	>（function(){}）是表达式；function(){}是函数声明；
	>
	>2.区别造成js在“预编译”阶段造成的差别：
	>
	>js在“预编译”阶段，会解释声明函数，但却会忽略表达式；
	>
	>3.当js执行到function(){}();的时候，由于function(){}在“预编译”阶段已经被解释过了，js会跳过function(){},试图去执行()；故会报错：Uncaught SyntaxError: Unexpected token ( 。
	>
	>当js执行到（function(){})(); 时候，由于(function(){})是一个表达式，js会对它求解并得到返回值，由于返回值是一个函数，故当遇到（）时候，边会执行此函数
	>
	>4.另外，将函数转换为表达式的方法不一定要靠分组操作符()，我们还可以用void操作符，~操作符，!操作符等等（）
```

#### closure(闭包)阮大侠

##### 1、理解closure之前

> 1、要理解closure,根本是javascript特殊的变量作用域问题；
>
> 2、js变量作用域分为两种：全局变量和局部变量；
>
> 3、js的特殊之处，就在于函数内部可以直接读取全局变量，另一方面，在函数外部自然无法读取到函数内部的局部变量

##### 2、按照上一步说的，我们如果想在函数外部想访问函数内部的变量？（closure引出）

> 出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。
>
> 那就是在函数的内部，再定义一个函数。
>
> ```javascript
> function f1(){
> 
> 　　　　var n=999;
> 
> 　　　　function f2(){
> 　　　　　　alert(n); // 999
> 　　　　}
> 
> 　　}
> ```
>
> 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的"链式作用域"结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。
>
> 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！
>
> ```javascript
> 　function f1(){
> 
> 　　　　var n=999;
> 
> 　　　　function f2(){
> 　　　　　　alert(n); 
> 　　　　}
> 
> 　　　　return f2;
> 
> 　　}
> 
> 　　var result=f1();
> 
> 　　result(); // 999
> ```

##### 3、closure概念

> 上一节代码中的f2函数，就是闭包;但在chrome里，认为f1是闭包。
>
> 各种专业文献上的"闭包"（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。
>
> 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成"定义在一个函数内部的函数"。
>
> 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁，闭包就是连接函数内部作用域和外部作用域的一座桥梁

##### 4、closrue的用途

> 闭包可以用在许多地方。它的最大用处有两个，**一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。**
>
> ```javascript
> function f1(){
> 
> 　　　　var n=999;
> 
> 　　　　nAdd=function(){n+=1}
> 
> 　　　　function f2(){
> 　　　　　　alert(n);
> 　　　　}
> 
> 　　　　return f2;
> 
> 　　}
> 
> 　　var result=f1();
> 
> 　　result(); // 999
> 
> 　　nAdd();
> 
> 　　result(); // 1000
> ```
>
> 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。
>
> 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。
>
> 这段代码中另一个值得注意的地方，就是"nAdd=function(){n+=1}"这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。



#### 二、用自运行匿名函数构造出的closure

#### 3、

>#### 闭包可以实现：
>
>返回函数；
>
>数据封装，不需要类的支持也能有private变量；
>
>模块：只要支持闭包就可以实现模块，参考nodejs；
>
>理论上还可以实现各种数据结构

#### 4、用途场景（自己总结）

>1、设置私有方法或私有变量（将闭包的词法作用域中的变量存在内存，不让垃圾回收机制回收）
>
>```javascript
>a = (function () {
>    var privatefunction = function () {
>        alert('hello');
>    }
>
>    return {
>        publicfunction : function () {
>            privatefunction();
>        }
>    }
>})();
>```
>
>用闭包来实现私有方法（privatefunction）或者私有变量；
>
>**声明：**一般都是认为父函数return的函数为闭包，但在chrome里，闭包却认为是父函数的名称（ 这里指组合表达式以及里边的内容 (function(){}) ）
>
>**疑问：**为什么要设置私有方法或私有变量？？？
>
>吐槽一句，网上所有的资料都是怎么实现私有方法私有变量的，全部都是复制粘贴，没有一篇自己走心，想要彻彻底底搞清事情来龙去脉的，最多提一句：在某些场景下需要私有变量，连为什么需要，哪些场景需要私有属性都不知道，就要去实现私有属性，纯属搞笑来的。。。
>
>```javascript
>function Test(){
>    this.count = 0;
>    this.add = function(){
>        this.count++;
>        console.log(this.count)
>    }
>}
>var a = new Test(); // {add: f, count: 0} 此时count和add都是公有属性
>a.add() // 1
>// 此时手动改变this.count的值
>a.count = 5
>a.add() // 6
>// 比如现在的需求是，每一个实例化的实体都需要从0开始递增；那我们现在这个类构造的就有缺陷，因为实体能够自行改变属性count的值，就有可能造成与创建类之处的初衷不一样的结果（Test类：实现count递增；而此种类的定义方法，就有可能在实体中修改count，造成实体中的count值不是递增）
>function Test(){
>    var count = 0
>    this.add = function(){
>        count++;
>        console.log(count)
>    }
>}
>var a = new Test() // {add: f} 打印a拿不到构造函数的（类）的私有属性（变量count）
>a.add() // 1 
>a.add() // 2
>```
>
>总结一下：个人目前对为什么要设置私有属性的观点是：在构造类的时候，需要一些不能让实例去访问和修改的变量和方法
>
>**延伸：**可以这么说：一切函数皆闭包
>
>可以这么理解这句话：一切函数在在创建的时候，它的作用域就确定了，该函数作用域中的变量都是私有变量（对于该函数外的作用域，例如window）,而该函数中的方法都会引用该作用域中的变量，此刻闭包就会生成！

