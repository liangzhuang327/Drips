> **原型**是ECMAScript实现**继承**的过程中产生的一个概念，为了搞清楚原型、原型链，我们首先要先了解一下什么是继承，js为什么要实现继承

###### 什么是继承

​	老规矩，上例子：现在从前端抽离一个model名为Person，其有基本的属性name和age，默认每个人都会说话。因此我们将说话的功能say放在了一个对象里（即原型对象上），以达到让每个实例享用（实例的person）；现在我想新建一个实例Man，它需要Person的name和age属性还要有通用的say属性。Man拥有Person属性的过程就可以成为继承



###### 为什么要继承

​	通常在一般的项目里用不到继承，因为应用简单。但是你要用js做一下复杂的工具（cube）或者框架的时候就用到了，比如jq，不然一个几千行的代码不用继承的估计会上万行，甚至无法维护



------

##### 

##### 本文解释原型，为了更好的理解并定义原型，我们这里采用倒叙来更好的深入的介绍原型

## 什么是原型

##### 1、为什么会需要构造函数（js中通过new运算符生成的函数）或者类（java中）

> **面对对象是很多程序的设计思想，是对真实世界的抽象，面对对象的基础就是类，通过对类的封装，继承来映射真实世界。**包括Java，C#，甚至是python等都通过类的设计来实现面对对象。但是细想起来也会觉得有问题，因为真实世界其实没有类这种概念，只有一个个不同的对象，真实世界中，**继承关系发生在对象和对象之间，而不是类**。就比如孩子是对象，父母也是对象，孩子（对象）继承自父母（对象）
>
>
> JavaScript也是面对对象的编程语言，只不过它实现面对对象的思路是基于原型（prototype），而不是类。这种思路也叫对象关联（Object Link Other Object），即在对象上直接映射那种真实世界的关系（如继承）。

##### 2、用构造函数或类生成的实例

> 虽然JavaScript是一门基于对象的语言，但是它却没有类的概念，**所以JavaScript中的对象和基于类的语言（如Java）中的对象有所不同**。JavaScript中的对象是无序属性的集合，其属性可以包含基本值，对象或者函数，听起来更像是键值对的集合，事实上也比较类似（有区别）。有了对象，**按理说就得有继承（为什么要有继承稍后解释）**，不然对象之间没有任何联系，也就真沦为键值对的集合了。那没有类的JavaScript是怎么实现继承的呢？
>
> 这里，我们通过构造函数生成一个实例对象
>
> ```javascript
> // 构造函数，无返回值
> function Person(name) {
>   this.name = name;
> }
> // 通过 new 新建一个对象
> var person = new Person('Mike');
> ```
>
>  

##### 3、实例和构造函数（或者类）之间的关系

> 如上面代码所示，`Person`是一个构造函数，`person`是一个实例，`person`继承了构造函数`Person`的属性和方法
>
> ```javascript
> function DOG(name){
>     this.name = name;
>     this.species = '犬科';
> }
> 
> //对这个构造函数使用new，就会生成一个狗对象的实例。
> var dogA = new DOG('大毛')；
> var dogB = new DOG('二毛')；
> console.log(dogA.species) //犬科
> console.log(dogB.species) //犬科
> ```
>
> dogA和dogB都继承了DOG构造函数的属性和方法，然而却存在一个问题就是：
>
> **这两个对象的species属性是独立的，修改其中一个，不会影响到另一个。**这便是通过`new`运算符的缺点，那就是**无法共享属性和方法**
>
> **缺点⚠️**：dogA和dogB除了属性一样外，并没有其他的任何联系，对象之间无法共享属性和方法。每当我们新建一个对象时，都会方法和属性分配一块新的内存，这是极大的资源浪费。

##### 4、原型

> 在上一步中存在的缺点问题，考虑到这一点，JavaScript 的设计者 Brendan Eich 决定为构造函数设置一个属性。这个属性指向一个对象，所有实例对象需要共享的属性和方法，都放在这个对象里面，那些不需要共享的属性和方法，就放在构造函数里面。实例对象一旦创建，将自动引用这个对象的属性和方法。也就是说，实例对象的属性和方法，分成两种，一种是本地的，不共享的，另一种是引用的，共享的。这个对象就是原型（prototype）对象，简称为原型。
>
> ```javascript
> function DOG(name){
>     this.name = name;
> }
> DOG.prototype = {species: '犬科'}
> var dogA = new DOG('大毛')；
> var dogB = new DOG('二毛')；
> console.log(dogA.species) // 犬科
> console.log(dogB.species) // 犬科
> ```
>
> **现在，species属性放在prototype对象里，是两个实例对象共享的。只要修改了prototype对象，就会同时影响到两个实例对象。**
>
> ```javascript
> DOG.prototype.species = '猫科';
> 
> alert(dogA.species); // 猫科
> alert(dogB.species); // 猫科
> ```
>
> 有原型和 全部属性方法写到构造函数的区别：
>
> ⚠️1、首先每个实例所占的内存会变小，实例中的原型属性只是原型对象中的对应属性的引用
>
> ⚠️2、生成完实例后，N多实例之间有联系，改变prototype就会改变所有实例中的属性或方法

## 与原型有关的一些属性

##### constructor与[[Prototype]]

> 我们知道每个函数都有一个prototype属性，指向函数的原型，因此当我们拿到一个函数的时候，就可以确定函数的原型。反之，如果给我们一个函数的原型，我们怎么知道这个原型是属于哪个函数呢？答案就是原型中constructor属性：
>
> **在默认情况下，所有原型对象都会自动获得一个 constructor （构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。**
>
> 也就是说每个原型都有一个constructor属性，指向了原型所在的函数
>
>

##### 本文借鉴原文⚠️

[JavaScript原型及原型链](https://hexianzhi.github.io/2017/04/27/JavaScript%E5%8E%9F%E5%9E%8B/)

[JavaScript原型详解](https://juejin.im/post/57f336a9816dfa00568f300c)

[深入理解 JavaScript 原型](https://juejin.im/post/5a0a5dc4f265da430b7abffb)



###### 