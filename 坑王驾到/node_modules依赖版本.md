![编译报错](https://github.com/liangzhuang327/Drips/blob/master/pictrues/build_error.jpeg)

#### 1、在build:dll的时候报错，即构建mainfest的时候报错，打开build:dll的配置文件，发现没有moment,但是uglify的时候报错？

> 查了查百度发现有人遇到过这种错误，是因为webpack3自带的webpack.optimize.UglifyJsPlugin在压缩的时候，不支持压缩es6的语法；

也就是说明moment有es6的语法，但看了看dll的webpack.config文件，没有发现moment这个依赖，怀疑是因为其他依赖引用了moment导致的，没多想就直接在config文件中加入如下代码，预先用babel-loader处理一下moment依赖
```js
rules:[
      {
        test: /\.js$/,
        loader: 'babel-loader',
        include: [path.resolve('/node_modules/moment/src')]
      }
    ]
```

至此解决编译报错的问题了

#### 2、编译过去了，在登录的时候，又报错，大概说的是monent的require等语法错误；
> 想了一下，dll的编译过去了，但是在我们自己的脚本中也有引用moment的地方，然后看了下
> wepback.config.product.js，即生产环境编译使用的配置文件，里边babel-loader也并没有处
> 理node_modules里边的依赖，也就是说明node_modules里边的moment依赖自己没有编译成es5的
> 语法，在直接引用的时候报错；本人觉得是此包的问题，按说所有npm的依赖包应该都自行编译成es5语
> 法能直接执行的；查看版本package.json中moment版本号是**^2.18.1**，实际的版本却是
> 2.25.1，查了一下正式环境的版本是2.24.0
> 得出结论应该是2.25.1这个版本有问题，但是2.24.0版本没问题，所有写死moment这个版本为
> 2.24.0，提交
> 完美解决

#### 3、登录进去，到某个单据里发现日期选择控件出现问题：
![日期控件出现英文](https://github.com/liangzhuang327/Drips/blob/master/pictrues/build_error.png)

> 因为最近没有代码改动，应该还是版本的问题导致的；我在调试窗口里搜索moment.js的时候发现了
> 了两个文件！node_modules/antd下边有一个moment包，node_modules下有一个moment包；
> 很显然，node_modules下的这个moment包是我自己写死的那个版本的2.24.0,
> 而node_modules/antd下边的moment包的版本是2.25.1很显然不是我装的，是antd自己装的；

##### 那么问题来了，为什么会有两个包，antd为什么会自己下一个包而不是用我下的那个包呢？
> 翻看了一下antd的package.json发现，里边引用的版本是^2.18.1,这种写法也就是说antd会自己下
> 2.x中的最新版本也就是2.25.1；然后看了下我用的组建datePicker引用的是rc-calendar,
> rc-calendar下边的package.json中moment版本写的是2.x也就是最新版本2.25.1；

解释
> 也就是说，我自己写死的版本2.24.0是位于node_modules的文件下，而开始下载antd的依赖的时候
> 发现外面moment的版本不是antd/rc-calendar的package.json中配置的版本，所以又下了
> 一次自己所需要的moment版本，也就是放到node_modules/antd／下边的moment,也就是2.25.1
> 那个版本；所以会出现两个moment包，antd组建所引用的是自己下载的moment包，而我们自己所引用
> 的moment却是我们自己主动下载的版本


解决：
既然知道这两个moment依赖包怎么来的了，就好解决了，只要保证外面的package.json，也就是我们项目根目录的package.json，配置的moment版本也要写成^2.x类似的版本，这样就能保证只下载一个包，所有的引用的地方都调用这一个包；
    但这样就又回到了第一个问题了，包里又es6的语法怎么解决？只能用babel-loader去解析一下
node_modules里的moemnt了，因为这是moment官方自己犯的错，只能我们在编译的时候自行处理了
> 思路有了，就开始行动了，把原来写死的版本去掉，重新下载2.x的版本。就在此时，经验的时刻来了！
> moment下载下来后我一看，这个版本是**2.25.3**，我又确认了一遍却是没有错，已经不是3天前那个
> 2.25.1了；从这信息里我百分之八十的肯定了，moment官方发现了这个hack,自己出补丁解决了！果断
> **把所有的预编译都去掉，写死的版本也去掉，一切的代码恢复到最开始**，提交，编译，部署，查看
> 好了！猜的没有错

#### 4、 moemnt版本问题总结：
虽然此次，是moment自己的失误，但却是也导致了线上代码的不可用，既然引用开源包就可能有这种问题不可避免，项目本身能做的很少，最后的方案也只能是生成一个packge.lock.json用来写死版本，但却是了开源包自己优化带来的好处，也没有太好的办法

#### 5、思考
##### 1、npm下载依赖包／模块的规则是什么？
[npm下载规则](https://www.cnblogs.com/wonyun/p/9349691.html);

包的依赖关系：
1、A模块引用了a, b两个模块，B模块引用了a,c两个模块（假定a的版本一致）
```js
// node_modules的依赖图，第一行代表第一级文件夹，第二行代表第二级文件夹

/**
 * A a b B c
*/
```
> 安装模块的时候；按照 package.json 里依赖的顺序依次解析，遇到新的包就把它放在第一级目录，
> 后面如果遇到一级目录已经存在的包，会先判断版本，如果版本一样则忽略，否则会按照 npm2 的方式
> 依次挂在依赖包目录下

2、A模块引用了a@2.1, b两个模块，B模块引用了a@1.5,c两个模块
```js
// node_modules的依赖图，第一行代表第一级文件夹，第二行代表第二级文件夹

/**
 * A a@2.1 b B c
 *           |
 *           \/
 *           a@1.5
*/
```
##### 2、页面引用模块的时候的规则是什么？
引用模块的时候(依赖包)的引用规则可以简单总结为`递归向上`

我们以antd的datePicker组建来举例子，因为datePicker中有引用moment包
```js
// 在A.js文件中引用DatePicker组建，组建调用moment的流程如下：

/**
 * 第一步：user/project/node_modules/antd/datePicker/node_modules/moment.js
 * 第二步：user/project/node_modules/antd／node_modules/moment.js
 * 第三步：user/project/node_modules/moment.js
 * 第四步：user/node_modules/moment.js
 * 第五步：./node_modules/moment.js
 * 第六步：再没找到 报错
*/
```
> 此处就能理解为什么datePicker中引用的moment版本是2.25.1而不是写死的2.17.1;向上找依赖的
> 时候先找到了node_modules/antd/node_moudles／moment.js了，所以就不会去引用
> node_modules/moment.js了；至于为什么生成两个版本，从思考一知道因为两个moment版本不一样